// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`should return command types 1`] = `
"/** START Preface */

export enum TimingTypes {
  ABSOLUTE = 'ABSOLUTE',
  COMMAND_RELATIVE = 'COMMAND_RELATIVE',
  EPOCH_RELATIVE = 'EPOCH_RELATIVE',
  COMMAND_COMPLETE = 'COMMAND_COMPLETE',
}

// @ts-ignore : 'Args' found in JSON Spec
export type CommandOptions<A extends Args[] | { [argName: string]: any } = [] | {}> = {
  stem: string;
  arguments: A;
  // @ts-ignore : 'Metadata' found in JSON Spec
  metadata?: Metadata | undefined;
  // @ts-ignore : 'Description' found in JSON Spec
  description?: Description | undefined;
  // @ts-ignore : 'Model' found in JSON Spec
  models?: Model[] | undefined;
} & (
  | {
      absoluteTime: Temporal.Instant;
    }
  | {
      epochTime: Temporal.Duration;
    }
  | {
      relativeTime: Temporal.Duration;
    }
  // CommandComplete
  | {}
);

export type GroundOptions = {
  name: string;
  // @ts-ignore : 'Args' found in JSON Spec
  args?: Args;
  // @ts-ignore : 'Description' found in JSON Spec
  description?: Description;
  // @ts-ignore : 'Metadata' found in JSON Spec
  metadata?: Metadata;
  // @ts-ignore : 'Model' found in JSON Spec
  models?: Model[];
} & (
  | {
      absoluteTime: Temporal.Instant;
    }
  | {
      epochTime: Temporal.Duration;
    }
  | {
      relativeTime: Temporal.Duration;
    }
  // CommandComplete
  | {}
);

export type Arrayable<T> = T | Arrayable<T>[];

export interface SequenceOptions {
  seqId: string;
  // @ts-ignore : 'Metadata' found in JSON Spec
  metadata: Metadata;

  // @ts-ignore : 'VariableDeclaration' found in JSON Spec
  locals?: [VariableDeclaration, ...VariableDeclaration[]];
  // @ts-ignore : 'VariableDeclaration' found in JSON Spec
  parameters?: [VariableDeclaration, ...VariableDeclaration[]];
  // @ts-ignore : 'Step' found in JSON Spec
  steps?: Step[];
  // @ts-ignore : 'Request' found in JSON Spec
  requests?: Request[];
  // @ts-ignore : 'ImmediateCommand' found in JSON Spec
  immediate_commands?: ImmediateCommand[];
  // @ts-ignore : 'HardwareCommand' found in JSON Spec
  hardware_commands?: HardwareCommand[];
}

declare global {
  // @ts-ignore : 'SeqJson' found in JSON Spec
  class Sequence implements SeqJson {
    public readonly id: string;
    // @ts-ignore : 'Metadata' found in JSON Spec
    public readonly metadata: Metadata;

    // @ts-ignore : 'VariableDeclaration' found in JSON Spec
    public readonly locals?: [VariableDeclaration, ...VariableDeclaration[]];
    // @ts-ignore : 'VariableDeclaration' found in JSON Spec
    public readonly parameters?: [VariableDeclaration, ...VariableDeclaration[]];
    // @ts-ignore : 'Step' found in JSON Spec
    public readonly steps?: Step[];
    // @ts-ignore : 'Request' found in JSON Spec
    public readonly requests?: Request[];
    // @ts-ignore : 'ImmediateCommand' found in JSON Spec
    public readonly immediate_commands?: ImmediateCommand[];
    // @ts-ignore : 'HardwareCommand' found in JSON Spec
    public readonly hardware_commands?: HardwareCommand[];
    [k: string]: unknown;

    public static new(
      opts:
        | {
            seqId: string;
            // @ts-ignore : 'VariableDeclaration' found in JSON Spec
            locals?: [VariableDeclaration, ...VariableDeclaration[]];
            // @ts-ignore : 'Metadata' found in JSON Spec
            metadata: Metadata;
            // @ts-ignore : 'VariableDeclaration' found in JSON Spec
            parameters?: [VariableDeclaration, ...VariableDeclaration[]];
            // @ts-ignore : 'Step' found in JSON Spec
            steps?: Step[];
            // @ts-ignore : 'Request' found in JSON Spec
            requests?: Request[];
            // @ts-ignore : 'ImmediateCommand' found in JSON Spec
            immediate_commands?: ImmediateCommand[];
            // @ts-ignore : 'HardwareCommand' found in JSON Spec
            hardware_commands?: HardwareCommand[];
          }
        // @ts-ignore : 'SeqJson' found in JSON Spec
        | SeqJson,
    ): Sequence;

    // @ts-ignore : 'SeqJson' found in JSON Spec
    public toSeqJson(): SeqJson;
  }

  // @ts-ignore : 'Args' found in JSON Spec
  class CommandStem<A extends Args[] | { [argName: string]: any } = [] | {}> implements Command {
    // @ts-ignore : 'Args' found in JSON Spec
    args: Args;
    stem: string;
    // @ts-ignore : 'TIME' found in JSON Spec
    time: Time;
    type: 'command';

    public static new<A extends any[] | { [argName: string]: any }>(opts: CommandOptions<A>): CommandStem<A>;

    // @ts-ignore : 'Command' found in JSON Spec
    public toSeqJson(): Command;

    // @ts-ignore : 'Model' found in JSON Spec
    public MODELS(models: Model[]): CommandStem<A>;
    // @ts-ignore : 'Model' found in JSON Spec
    public GET_MODELS(): Model[] | undefined;

    // @ts-ignore : 'Metadata' found in JSON Spec
    public METADATA(metadata: Metadata): CommandStem<A>;
    // @ts-ignore : 'Metadata' found in JSON Spec
    public GET_METADATA(): Metadata | undefined;

    // @ts-ignore : 'Description' found in JSON Spec
    public DESCRIPTION(description: Description): CommandStem<A>;
    // @ts-ignore : 'Description' found in JSON Spec
    public GET_DESCRIPTION(): Description | undefined;
  }

  const STEPS: {
    GROUND_BLOCK: typeof GROUND_BLOCK;
    GROUND_EVENT: typeof GROUND_EVENT;
  };

  type Context = {};
  type ExpansionReturn = Arrayable<CommandStem>;

  type U<BitLength extends 8 | 16 | 32 | 64> = number;
  type U8 = U<8>;
  type U16 = U<16>;
  type U32 = U<32>;
  type U64 = U<64>;
  type I<BitLength extends 8 | 16 | 32 | 64> = number;
  type I8 = I<8>;
  type I16 = I<16>;
  type I32 = I<32>;
  type I64 = I<64>;
  type VarString<PrefixBitLength extends number, MaxBitLength extends number> = string;
  type FixedString = string;
  type F<BitLength extends 32 | 64> = number;
  type F32 = F<32>;
  type F64 = F<64>;

  // @ts-ignore : 'Commands' found in generated code
  function A(...args: [TemplateStringsArray, ...string[]]): typeof Commands & typeof STEPS;
  // @ts-ignore : 'Commands' found in generated code
  function A(absoluteTime: Temporal.Instant): typeof Commands & typeof STEPS;
  // @ts-ignore : 'Commands' found in generated code
  function A(timeDOYString: string): typeof Commands;

  // @ts-ignore : 'Commands' found in generated code
  function R(...args: [TemplateStringsArray, ...string[]]): typeof Commands & typeof STEPS;
  // @ts-ignore : 'Commands' found in generated code
  function R(duration: Temporal.Duration): typeof Commands & typeof STEPS;
  // @ts-ignore : 'Commands' found in generated code
  function R(timeHMSString: string): typeof Commands & typeof STEPS;

  // @ts-ignore : 'Commands' found in generated code
  function E(...args: [TemplateStringsArray, ...string[]]): typeof Commands & typeof STEPS;
  // @ts-ignore : 'Commands' found in generated code
  function E(duration: Temporal.Duration): typeof Commands & typeof STEPS;
  // @ts-ignore : 'Commands' found in generated code
  function E(timeHMSString: string): typeof Commands & typeof STEPS;

  // @ts-ignore : 'Commands' found in generated code
  const C: typeof Commands & typeof STEPS;
}

/*
	---------------------------------
				Sequence eDSL
	---------------------------------
	*/
// @ts-ignore : 'SeqJson' found in JSON Spec
export class Sequence implements SeqJson {
  public readonly id: string;
  // @ts-ignore : 'Metadata' found in JSON Spec
  public readonly metadata: Metadata;

  // @ts-ignore : 'VariableDeclaration' found in JSON Spec
  public readonly locals?: [VariableDeclaration, ...VariableDeclaration[]];
  // @ts-ignore : 'VariableDeclaration' found in JSON Spec
  public readonly parameters?: [VariableDeclaration, ...VariableDeclaration[]];
  // @ts-ignore : 'Step' found in JSON Spec
  public readonly steps?: Step[];
  // @ts-ignore : 'Request' found in JSON Spec
  public readonly requests?: Request[];
  // @ts-ignore : 'ImmediateCommand' found in JSON Spec
  public readonly immediate_commands?: ImmediateCommand[];
  // @ts-ignore : 'HardwareCommand' found in JSON Spec
  public readonly hardware_commands?: HardwareCommand[];
  [k: string]: unknown;

  // @ts-ignore : 'SeqJson' found in JSON Spec
  private constructor(opts: SequenceOptions | SeqJson) {
    if ('id' in opts) {
      this.id = opts.id;
    } else {
      this.id = opts.seqId;
    }
    this.metadata = opts.metadata;

    this.locals = opts.locals ?? undefined;
    this.parameters = opts.parameters ?? undefined;
    this.steps = opts.steps ?? undefined;
    this.requests = opts.requests ?? undefined;
    this.immediate_commands = opts.immediate_commands ?? undefined;
    this.hardware_commands = opts.hardware_commands ?? undefined;
  }
  public static new(opts: SequenceOptions): Sequence {
    return new Sequence(opts);
  }

  // @ts-ignore : 'SeqJson' found in JSON Spec
  public toSeqJson(): SeqJson {
    return {
      id: this.id,
      metadata: this.metadata,
      ...(this.steps
        ? {
            steps: this.steps.map(step => {
              if (step instanceof CommandStem || step instanceof Ground_Block || step instanceof Ground_Event)
                return step.toSeqJson();
              return step;
            }),
          }
        : {}),
      ...(this.locals ? { locals: this.locals } : {}),
      ...(this.parameters ? { parameters: this.parameters } : {}),
      ...(this.requests
        ? {
            requests: this.requests.map(request => {
              return {
                name: request.name,
                steps: [
                  request.steps[0] instanceof CommandStem ||
                  request.steps[0] instanceof Ground_Block ||
                  request.steps[0] instanceof Ground_Event
                    ? request.steps[0].toSeqJson()
                    : request.steps[0],
                  // @ts-ignore : 'step' found in JSON Spec
                  ...request.steps.slice(1).map(step => {
                    if (step instanceof CommandStem || step instanceof Ground_Block || step instanceof Ground_Event)
                      return step.toSeqJson();
                    return step;
                  }),
                ],
                type: request.type,
                ...(request.description ? { description: request.description } : {}),
                ...(request.ground_epoch ? { ground_epoch: request.ground_epoch } : {}),
                ...(request.time ? { time: request.time } : {}),
                ...(request.metadata ? { metadata: request.metadata } : {}),
              };
            }),
          }
        : {}),
      ...(this.immediate_commands ? { immediate_commands: this.immediate_commands } : {}),
      ...(this.hardware_commands ? { hardware_commands: this.hardware_commands } : {}),
    };
  }

  public toEDSLString(): string {
    const commandsString =
      this.steps && this.steps.length > 0
        ? '[\\n' +
          indent(
            this.steps
              .map(step => {
                if (step instanceof CommandStem || step instanceof Ground_Block || step instanceof Ground_Event) {
                  return step.toEDSLString() + ',';
                }
                return objectToString(step) + ',';
              })
              .join('\\n'),
            1,
          ) +
          '\\n]'
        : '';
    //ex.
    // [C.ADD_WATER]
    const metadataString = Object.keys(this.metadata).length == 0 ? \`{}\` : \`\${objectToString(this.metadata)}\`;

    const localsString = this.locals ? \`[\\n\${indent(this.locals.map(l => objectToString(l)).join(',\\n'), 1)}\\n]\` : '';

    const parameterString = this.parameters
      ? \`[\\n\${indent(this.parameters.map(l => objectToString(l)).join(',\\n'), 1)}\\n]\`
      : '';
    //ex.
    // \`parameters: [
    //   {
    //     allowable_ranges: [
    //       {
    //         max: 3600,
    //         min: 1,
    //       },
    //     ],
    //     name: 'duration',
    //     type: 'UINT',
    //   }
    // ]\`;

    const hardwareString = this.hardware_commands
      ? \`[\\n\${indent(this.hardware_commands.map(h => objectToString(h)).join(',\\n'), 1)}\\n]\`
      : '';
    //ex.
    // hardware_commands: [
    //   {
    //     description: 'FIRE THE PYROS',
    //     metadata:{
    //       author: 'rrgoetz',
    //     },
    //     stem: 'HDW_PYRO_ENGINE',
    //   }
    // ],

    const immediateString = this.immediate_commands
      ? \`[\\n\${indent(this.immediate_commands.map(i => objectToString(i)).join(',\\n'), 1)}\\n]\`
      : '';
    //ex.
    // immediate_commands: [
    //   {
    //     args: [
    //       {
    //         name: 'direction',
    //         type: 'string',
    //         value: 'FromStem',
    //       },
    //     ],
    //     stem: 'PEEL_BANANA',
    //   }
    // ]

    const requestString = this.requests
      ? \`[\\n\${indent(
          this.requests
            .map(r => {
              return (
                \`{\\n\` +
                indent(
                  \`name: '\${r.name}',\\n\` +
                    \`steps: [\\n\${indent(
                      r.steps
                        // @ts-ignore : 's: Step' found in JSON Spec
                        .map(s => {
                          if (s instanceof CommandStem || s instanceof Ground_Block || s instanceof Ground_Event) {
                            return s.toEDSLString() + ',';
                          }
                          return objectToString(s) + ',';
                        })
                        .join('\\n'),
                      1,
                    )}\\n],\` +
                    \`\\ntype: '\${r.type}',\` +
                    \`\${r.description ? \`\\ndescription: '\${r.description}',\` : ''}\` +
                    \`\${r.ground_epoch ? \`\\nground_epoch: \${objectToString(r.ground_epoch)},\` : ''}\` +
                    \`\${r.time ? \`\\ntime: \${objectToString(r.time)},\` : ''}\` +
                    \`\${r.metadata ? \`\\nmetadata: \${objectToString(r.metadata)},\` : ''}\`,
                  1,
                ) +
                \`\\n}\`
              );
            })
            .join(',\\n'),
          1,
        )}\\n]\`
      : '';
    //ex.
    /*requests: [
        {
          name: 'power',
          steps: [
            R\`04:39:22.000\`.PREHEAT_OVEN({
              temperature: 360,
            }),
            C.ADD_WATER,
          ],
          type: 'request',
          description: ' Activate the oven',
          ground_epoch: {
            delta: 'now',
            name: 'activate',
          },
          metadata: {
            author: 'rrgoet',
          },
        }
      ]
    }*/

    return (
      \`export default () =>\\n\` +
      \`\${indent(\`Sequence.new({\`, 1)}\\n\` +
      \`\${indent(\`seqId: '\${this.id}'\`, 2)},\\n\` +
      \`\${indent(\`metadata: \${metadataString}\`, 2)},\\n\` +
      \`\${localsString.length !== 0 ? \`\${indent(\`locals: \${localsString}\`, 2)},\\n\` : ''}\` +
      \`\${parameterString.length !== 0 ? \`\${indent(\`parameters: \${parameterString}\`, 2)},\\n\` : ''}\` +
      \`\${commandsString.length !== 0 ? \`\${indent(\`steps: \${commandsString}\`, 2)},\\n\` : ''}\` +
      \`\${hardwareString.length !== 0 ? \`\${indent(\`hardware_commands: \${hardwareString}\`, 2)},\\n\` : ''}\` +
      \`\${immediateString.length !== 0 ? \`\${indent(\`immediate_commands: \${immediateString}\`, 2)},\\n\` : ''}\` +
      \`\${requestString.length !== 0 ? \`\${indent(\`requests: \${requestString}\`, 2)},\\n\` : ''}\` +
      \`\${indent(\`});\`, 1)}\`
    );
  }

  // @ts-ignore : 'Args' found in JSON Spec
  public static fromSeqJson(json: SeqJson): Sequence {
    return Sequence.new({
      seqId: json.id,
      metadata: json.metadata,
      // @ts-ignore : 'Step' found in JSON Spec
      ...(json.steps
        ? {
            // @ts-ignore : 'Step' found in JSON Spec
            steps: json.steps.map((c: Step) => {
              if (c.type === 'command') return CommandStem.fromSeqJson(c as CommandStem);
              else if (c.type === 'ground_block') return Ground_Block.fromSeqJson(c as Ground_Block);
              else if (c.type === 'ground_event') return Ground_Event.fromSeqJson(c as Ground_Event);
              return c;
            }),
          }
        : {}),
      ...(json.locals ? { locals: json.locals } : {}),
      ...(json.parameters ? { parameters: json.parameters } : {}),
      ...(json.requests
        ? {
            // @ts-ignore : 'r: Request' found in JSON Spec
            requests: json.requests.map(r => {
              return {
                name: r.name,
                type: r.type,
                ...(r.description ? { description: r.description } : {}),
                ...(r.ground_epoch ? { ground_epoch: r.ground_epoch } : {}),
                ...(r.time ? { time: r.time } : {}),
                ...(r.metadata ? { metadata: r.metadata } : {}),
                steps: [
                  r.steps[0].type === 'command'
                    ? CommandStem.fromSeqJson(r.steps[0] as CommandStem)
                    : r.steps[0].type === 'ground_block'
                    ? // @ts-ignore : 'GroundBlock' found in JSON Spec
                      Ground_Block.fromSeqJson(r.steps[0] as GroundBlock)
                    : r.steps[0].type === 'ground_event'
                    ? // @ts-ignore : 'GroundEvent' found in JSON Spec
                      Ground_Event.fromSeqJson(r.steps[0] as GroundEvent)
                    : r.steps[0],
                  // @ts-ignore : 'step : Step' found in JSON Spec
                  ...r.steps.slice(1).map(step => {
                    if (step.type === 'command') return CommandStem.fromSeqJson(step as CommandStem);
                    else if (step.type === 'ground_block') return Ground_Block.fromSeqJson(step as Ground_Block);
                    else if (step.type === 'ground_event') return Ground_Event.fromSeqJson(step as Ground_Event);
                    return step;
                  }),
                ],
              };
            }),
          }
        : {}),
      ...(json.immediate_commands ? { immediate_commands: json.immediate_commands } : {}),
      ...(json.hardware_commands ? { hardware_commands: json.hardware_commands } : {}),
    });
  }
}

/*
	---------------------------------
				STEPS eDSL
	---------------------------------
	*/

// @ts-ignore : 'Args' found in JSON Spec
export class CommandStem<A extends Args[] | { [argName: string]: any } = [] | {}> implements Command {
  public readonly arguments: A;
  public readonly absoluteTime: Temporal.Instant | null = null;
  public readonly epochTime: Temporal.Duration | null = null;
  public readonly relativeTime: Temporal.Duration | null = null;

  public readonly stem: string;
  // @ts-ignore : 'Args' found in JSON Spec
  public readonly args!: Args;
  // @ts-ignore : 'Time' found in JSON Spec
  public readonly time!: Time;
  // @ts-ignore : 'Model' found in JSON Spec
  private readonly _models?: Model[] | undefined;
  // @ts-ignore : 'Metadata' found in JSON Spec
  private readonly _metadata?: Metadata | undefined;
  // @ts-ignore : 'Description' found in JSON Spec
  private readonly _description?: Description | undefined;
  public readonly type: 'command' = 'command';

  private constructor(opts: CommandOptions<A>) {
    this.stem = opts.stem;
    this.arguments = opts.arguments;

    if ('absoluteTime' in opts) {
      this.absoluteTime = opts.absoluteTime;
    } else if ('epochTime' in opts) {
      this.epochTime = opts.epochTime;
    } else if ('relativeTime' in opts) {
      this.relativeTime = opts.relativeTime;
    }
    this._metadata = opts.metadata;
    this._description = opts.description;
    this._models = opts.models;
  }

  public static new<A extends any[] | { [argName: string]: any }>(opts: CommandOptions<A>): CommandStem<A> {
    if ('absoluteTime' in opts) {
      return new CommandStem<A>({
        ...opts,
        absoluteTime: opts.absoluteTime,
      });
    } else if ('epochTime' in opts) {
      return new CommandStem<A>({
        ...opts,
        epochTime: opts.epochTime,
      });
    } else if ('relativeTime' in opts) {
      return new CommandStem<A>({
        ...opts,
        relativeTime: opts.relativeTime,
      });
    } else {
      return new CommandStem<A>(opts);
    }
  }

  // @ts-ignore : 'Model' found in JSON Spec
  public MODELS(models: Model[]): CommandStem {
    return CommandStem.new({
      stem: this.stem,
      arguments: this.arguments,
      models: models,
      metadata: this._metadata,
      description: this._description,
      ...(this.absoluteTime && { absoluteTime: this.absoluteTime }),
      ...(this.epochTime && { epochTime: this.epochTime }),
      ...(this.relativeTime && { relativeTime: this.relativeTime }),
    });
  }

  // @ts-ignore : 'Model' found in JSON Spec
  public GET_MODELS(): Model[] | undefined {
    return this._models;
  }

  // @ts-ignore : 'Metadata' found in JSON Spec
  public METADATA(metadata: Metadata): CommandStem {
    return CommandStem.new({
      stem: this.stem,
      arguments: this.arguments,
      models: this._models,
      metadata: metadata,
      description: this._description,
      ...(this.absoluteTime && { absoluteTime: this.absoluteTime }),
      ...(this.epochTime && { epochTime: this.epochTime }),
      ...(this.relativeTime && { relativeTime: this.relativeTime }),
    });
  }

  // @ts-ignore : 'Metadata' found in JSON Spec
  public GET_METADATA(): Metadata | undefined {
    return this._metadata;
  }

  // @ts-ignore : 'Description' found in JSON Spec
  public DESCRIPTION(description: Description): CommandStem {
    return CommandStem.new({
      stem: this.stem,
      arguments: this.arguments,
      models: this._models,
      metadata: this._metadata,
      description: description,
      ...(this.absoluteTime && { absoluteTime: this.absoluteTime }),
      ...(this.epochTime && { epochTime: this.epochTime }),
      ...(this.relativeTime && { relativeTime: this.relativeTime }),
    });
  }
  // @ts-ignore : 'Description' found in JSON Spec
  public GET_DESCRIPTION(): Description | undefined {
    return this._description;
  }

  // @ts-ignore : 'Command' found in JSON Spec
  public toSeqJson(): Command {
    return {
      args: CommandStem.convertArgsToInterfaces(this.arguments),
      stem: this.stem,
      time:
        this.absoluteTime !== null
          ? { type: TimingTypes.ABSOLUTE, tag: instantToDoy(this.absoluteTime) }
          : this.epochTime !== null
          ? { type: TimingTypes.EPOCH_RELATIVE, tag: durationToHms(this.epochTime) }
          : this.relativeTime !== null
          ? { type: TimingTypes.COMMAND_RELATIVE, tag: durationToHms(this.relativeTime) }
          : { type: TimingTypes.COMMAND_COMPLETE },
      type: this.type,
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { models: this._models } : {}),
      ...(this._description ? { description: this._description } : {}),
    };
  }

  // @ts-ignore : 'Command' found in JSON Spec
  public static fromSeqJson(json: Command): CommandStem {
    const timeValue =
      json.time.type === TimingTypes.ABSOLUTE
        ? { absoluteTime: doyToInstant(json.time.tag as DOY_STRING) }
        : json.time.type === TimingTypes.COMMAND_RELATIVE
        ? { relativeTime: hmsToDuration(json.time.tag as HMS_STRING) }
        : json.time.type === TimingTypes.EPOCH_RELATIVE
        ? { epochTime: hmsToDuration(json.time.tag as HMS_STRING) }
        : {};

    return CommandStem.new({
      stem: json.stem,
      arguments: CommandStem.convertInterfacesToArgs(json.args),
      metadata: json.metadata,
      models: json.models,
      description: json.description,
      ...timeValue,
    });
  }

  public absoluteTiming(absoluteTime: Temporal.Instant): CommandStem<A> {
    return CommandStem.new({
      stem: this.stem,
      arguments: this.arguments,
      absoluteTime: absoluteTime,
    });
  }

  public epochTiming(epochTime: Temporal.Duration): CommandStem<A> {
    return CommandStem.new({
      stem: this.stem,
      arguments: this.arguments,
      epochTime: epochTime,
    });
  }

  public relativeTiming(relativeTime: Temporal.Duration): CommandStem<A> {
    return CommandStem.new({
      stem: this.stem,
      arguments: this.arguments,
      relativeTime: relativeTime,
    });
  }

  public toEDSLString(): string {
    const timeString = this.absoluteTime
      ? \`A\\\`\${instantToDoy(this.absoluteTime)}\\\`\`
      : this.epochTime
      ? \`E\\\`\${durationToHms(this.epochTime)}\\\`\`
      : this.relativeTime
      ? \`R\\\`\${durationToHms(this.relativeTime)}\\\`\`
      : 'C';

    const argsString =
      Object.keys(this.arguments).length === 0 ? '' : \`(\${CommandStem.argumentsToString(this.arguments)})\`;

    const metadata =
      this._metadata && Object.keys(this._metadata).length !== 0
        ? \`\\n.METADATA(\${objectToString(this._metadata)})\`
        : '';
    const description =
      this._description && this._description.length !== 0 ? \`\\n.DESCRIPTION('\${this._description}')\` : '';
    const models =
      this._models && Object.keys(this._models).length !== 0
        ? \`\\n.MODELS([\\n\${this._models.map(m => indent(objectToString(m))).join(',\\n')}\\n])\`
        : '';
    return \`\${timeString}.\${this.stem}\${argsString}\${description}\${metadata}\${models}\`;
  }

  // @ts-ignore : 'Args' found in JSON Spec
  private static argumentsToString<A extends Args[] | { [argName: string]: any } = [] | {}>(args: A): string {
    if (Array.isArray(args)) {
      const argStrings = args.map(arg => {
        if (typeof arg === 'string') {
          return \`'\${arg}'\`;
        }
        return arg.toString();
      });

      return argStrings.join(', ');
    } else {
      return objectToString(args);
    }
  }

  // This function takes an array of Args interfaces and converts it into an object.
  // The interfaces array contains objects matching the ARGS interface.
  // Depending on the type property of each object, a corresponding object with the name and value properties is created
  // and added to the output.
  // Additionally, the function includes a validation function that prevents remote property injection attacks.
  // @ts-ignore : 'Args' found in JSON Spec
  private static convertInterfacesToArgs(interfaces: Args): {} | [] {
    const args = interfaces.length === 0 ? [] : {};

    // Use to prevent a Remote property injection attack
    const validate = (input: string): boolean => {
      const pattern = /^[a-zA-Z0-9_-]+$/;
      const isValid = pattern.test(input);
      return isValid;
    };

    const convertedArgs = interfaces.map(
      (
        // @ts-ignore : found in JSON Spec
        arg: StringArgument | NumberArgument | BooleanArgument | SymbolArgument | HexArgument | RepeatArgument,
      ) => {
        // @ts-ignore : 'RepeatArgument' found in JSON Spec
        if (arg.type === 'repeat') {
          if (validate(arg.name)) {
            // @ts-ignore : 'RepeatArgument' found in JSON Spec
            return {
              [arg.name]: arg.value.map(
                (
                  // @ts-ignore : found in JSON Spec
                  repeatArgBundle: (StringArgument | NumberArgument | BooleanArgument | SymbolArgument | HexArgument)[],
                ) =>
                  repeatArgBundle.reduce((obj, item) => {
                    if (validate(item.name)) {
                      obj[item.name] = item.value;
                    }
                    return obj;
                  }, {}),
              ),
            };
          }
          return { repeat_error: 'Remote property injection detected...' };
        } else if (arg.type === 'symbol') {
          if (validate(arg.name)) {
            // @ts-ignore : 'SymbolArgument' found in JSON Spec
            return { [arg.name]: { symbol: arg.value } };
          }
          return { symbol_error: 'Remote property injection detected...' };
          // @ts-ignore : 'HexArgument' found in JSON Spec
        } else if (arg.type === 'hex') {
          if (validate(arg.name)) {
            // @ts-ignore : 'HexArgument' found in JSON Spec
            return { [arg.name]: { hex: arg.value } };
          }
          return { hex_error: 'Remote property injection detected...' };
        } else {
          if (validate(arg.name)) {
            return { [arg.name]: arg.value };
          }
          return { error: 'Remote property injection detected...' };
        }
      },
    );

    for (const key in convertedArgs) {
      Object.assign(args, convertedArgs[key]);
    }

    return args;
  }

  /**
   * The specific function to handle repeat args, we need to do this separately because
   * you cannot have a RepeatArgument inside a RepeatArgument.
   *
   * @param args
   * @returns
   */
  private static convertRepeatArgs(args: { [argName: string]: any }): any[] {
    let result: any[] = [];

    if (args['length'] === 0) {
      return result;
    }

    const values = Array.isArray(args) ? args[0] : args;

    for (let key in values) {
      result.push(this.convertValueToObject(values[key], key));
    }

    return result;
  }

  /**
   * This function takes a value and key and converts it to the correct object type supported by the seqjson spec.
   * The only type not supported here is RepeatArgument, as that is handled differently because you cannot have a
   * RepeatArgument inside a RepeatArgument.
   *
   * @param value
   * @param key
   * @returns An object for each type
   */
  private static convertValueToObject(value: any, key: string): any {
    switch (typeof value) {
      case 'string':
        return { type: 'string', value: value, name: key };
      case 'number':
        return { type: 'number', value: value, name: key };
      case 'boolean':
        return { type: 'boolean', value: value, name: key };
      default:
        if (value instanceof Object && value.symbol && value.symbol === 'string') {
          return { type: 'symbol', value: value, name: key };
        } else if (
          value instanceof Object &&
          value.hex &&
          value.hex === 'string' &&
          new RegExp('^0x([0-9A-F])+$').test(value.hex)
        ) {
          return { type: 'hex', value: value, name: key };
        }
    }
  }

  //The function takes an object of arguments and converts them into the Args type. It does this by looping through the
  // values and pushing a new argument type to the result array depending on the type of the value.
  // If the value is an array, it will create a RepeatArgument type and recursively call on the values of the array.
  // the function returns the result array of argument types -
  // StringArgument, NumberArgument, BooleanArgument, SymbolArgument, HexArgument, and RepeatArgument.
  // @ts-ignore : 'Args' found in JSON Spec
  private static convertArgsToInterfaces(args: { [argName: string]: any }): Args {
    // @ts-ignore : 'Args' found in JSON Spec
    let result: Args = [];
    if (args['length'] === 0) {
      return result;
    }

    const values = Array.isArray(args) ? args[0] : args;

    for (let key in values) {
      let value = values[key];
      if (Array.isArray(value)) {
        // @ts-ignore : 'RepeatArgument' found in JSON Spec
        let repeatArg: RepeatArgument = {
          value: value.map(arg => {
            return this.convertRepeatArgs(arg);
          }),
          type: 'repeat',
          name: key,
        };
        result.push(repeatArg);
      } else {
        result = result.concat(this.convertValueToObject(value, key));
      }
    }
    return result;
  }
}
// @ts-ignore : 'GroundBlock' found in JSON Spec
export class Ground_Block implements GroundBlock {
  name: string;
  // @ts-ignore : 'Time' found in JSON Spec
  time!: Time;
  type: 'ground_block' = 'ground_block';

  private readonly _absoluteTime: Temporal.Instant | null = null;
  private readonly _epochTime: Temporal.Duration | null = null;
  private readonly _relativeTime: Temporal.Duration | null = null;

  // @ts-ignore : 'Args' found in JSON Spec
  private readonly _args: Args | undefined;
  // @ts-ignore : 'Description' found in JSON Spec
  private readonly _description: Description | undefined;
  // @ts-ignore : 'Metadata' found in JSON Spec
  private readonly _metadata: Metadata | undefined;
  // @ts-ignore : 'Model' found in JSON Spec
  private readonly _models: Model[] | undefined;

  constructor(opts: GroundOptions) {
    this.name = opts.name;

    this._args = opts.args ?? undefined;
    this._description = opts.description ?? undefined;
    this._metadata = opts.metadata ?? undefined;
    this._models = opts.models ?? undefined;

    if ('absoluteTime' in opts) {
      this._absoluteTime = opts.absoluteTime;
    } else if ('epochTime' in opts) {
      this._epochTime = opts.epochTime;
    } else if ('relativeTime' in opts) {
      this._relativeTime = opts.relativeTime;
    }
  }

  public static new(opts: GroundOptions): Ground_Block {
    return new Ground_Block(opts);
  }

  public absoluteTiming(absoluteTime: Temporal.Instant): Ground_Block {
    return new Ground_Block({
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { model: this._models } : {}),
      name: this.name,
      absoluteTime: absoluteTime,
    });
  }

  public epochTiming(epochTime: Temporal.Duration): Ground_Block {
    return new Ground_Block({
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { model: this._models } : {}),
      name: this.name,
      epochTime: epochTime,
    });
  }

  public relativeTiming(relativeTime: Temporal.Duration): Ground_Block {
    return new Ground_Block({
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { model: this._models } : {}),
      name: this.name,
      relativeTime: relativeTime,
    });
  }

  // @ts-ignore : 'Model' found in JSON Spec
  public MODELS(models: Model[]): Ground_Block {
    return Ground_Block.new({
      name: this.name,
      models: models,
      ...(this._args && { args: this._args }),
      ...(this._description && { description: this._description }),
      ...(this._metadata && { metadata: this._metadata }),
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }

  // @ts-ignore : 'Model' found in JSON Spec
  public GET_MODELS(): Model[] | undefined {
    return this._models;
  }

  // @ts-ignore : 'Metadata' found in JSON Spec
  public METADATA(metadata: Metadata): Ground_Block {
    return Ground_Block.new({
      name: this.name,
      ...(this._models && { models: this._models }),
      ...(this._args && { args: this._args }),
      ...(this._description && { description: this._description }),
      metadata: metadata,
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }

  // @ts-ignore : 'Metadata' found in JSON Spec
  public GET_METADATA(): Metadata | undefined {
    return this._metadata;
  }

  // @ts-ignore : 'Description' found in JSON Spec
  public DESCRIPTION(description: Description): Ground_Block {
    return Ground_Block.new({
      name: this.name,
      ...(this._models && { models: this._models }),
      ...(this._args && { args: this._args }),
      description: description,
      ...(this._metadata && { metadata: this._metadata }),
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }
  // @ts-ignore : 'Description' found in JSON Spec
  public GET_DESCRIPTION(): Description | undefined {
    return this._description;
  }

  // @ts-ignore : 'Description' found in JSON Spec
  public ARGUMENTS(args: Args): Ground_Block {
    return Ground_Block.new({
      name: this.name,
      ...(this._models && { models: this._models }),
      args: args,
      ...(this._description && { description: this._description }),
      ...(this._metadata && { metadata: this._metadata }),
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }

  // @ts-ignore : 'Description' found in JSON Spec
  public GET_ARGUMENTS(): Args | undefined {
    return this._args;
  }

  // @ts-ignore : 'GroundBlock' found in JSON Spec
  public toSeqJson(): GroundBlock {
    return {
      name: this.name,
      time:
        this._absoluteTime !== null
          ? { type: TimingTypes.ABSOLUTE, tag: instantToDoy(this._absoluteTime) }
          : this._epochTime !== null
          ? { type: TimingTypes.EPOCH_RELATIVE, tag: durationToHms(this._epochTime) }
          : this._relativeTime !== null
          ? { type: TimingTypes.COMMAND_RELATIVE, tag: durationToHms(this._relativeTime) }
          : { type: TimingTypes.COMMAND_COMPLETE },
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { models: this._models } : {}),
      type: this.type,
    };
  }

  // @ts-ignore : 'GroundBlock' found in JSON Spec
  public static fromSeqJson(json: GroundBlock): Ground_Block {
    const timeValue =
      json.time.type === TimingTypes.ABSOLUTE
        ? { absoluteTime: doyToInstant(json.time.tag as DOY_STRING) }
        : json.time.type === TimingTypes.COMMAND_RELATIVE
        ? { relativeTime: hmsToDuration(json.time.tag as HMS_STRING) }
        : json.time.type === TimingTypes.EPOCH_RELATIVE
        ? { epochTime: hmsToDuration(json.time.tag as HMS_STRING) }
        : {};

    return Ground_Block.new({
      name: json.name,
      ...(json.args ? { args: json.args } : {}),
      ...(json.description ? { description: json.description } : {}),
      ...(json.metadata ? { metadata: json.metadata } : {}),
      ...(json.models ? { models: json.models } : {}),
      ...timeValue,
    });
  }

  public toEDSLString(): string {
    const timeString = this._absoluteTime
      ? \`A\\\`\${instantToDoy(this._absoluteTime)}\\\`\`
      : this._epochTime
      ? \`E\\\`\${durationToHms(this._epochTime)}\\\`\`
      : this._relativeTime
      ? \`R\\\`\${durationToHms(this._relativeTime)}\\\`\`
      : 'C';

    const args =
      this._args && Object.keys(this._args).length !== 0
        ? // @ts-ignore : 'A : Args' found in JSON Spec
          \`\\n.ARGUMENTS([\\n\${this._args.map(a => indent(objectToString(a))).join(',\\n')}\\n])\`
        : '';

    const metadata =
      this._metadata && Object.keys(this._metadata).length !== 0
        ? \`\\n.METADATA(\${objectToString(this._metadata)})\`
        : '';

    const description =
      this._description && this._description.length !== 0 ? \`\\n.DESCRIPTION('\${this._description}')\` : '';

    const models =
      this._models && Object.keys(this._models).length !== 0
        ? \`\\n.MODELS([\\n\${this._models.map(m => indent(objectToString(m))).join(',\\n')}\\n])\`
        : '';

    return \`\${timeString}.GROUND_BLOCK('\${this.name}')\${args}\${description}\${metadata}\${models}\`;
  }
}

/**
 * This is a Ground Block step
 *
 */
function GROUND_BLOCK(name: string) {
  return new Ground_Block({ name: name });
}

// @ts-ignore : 'GroundBlock' found in JSON Spec
export class Ground_Event implements GroundEvent {
  name: string;
  // @ts-ignore : 'Time' found in JSON Spec
  time!: Time;
  type: 'ground_event' = 'ground_event';

  private readonly _absoluteTime: Temporal.Instant | null = null;
  private readonly _epochTime: Temporal.Duration | null = null;
  private readonly _relativeTime: Temporal.Duration | null = null;

  // @ts-ignore : 'Args' found in JSON Spec
  private readonly _args: Args | undefined;
  // @ts-ignore : 'Description' found in JSON Spec
  private readonly _description: Description | undefined;
  // @ts-ignore : 'Metadata' found in JSON Spec
  private readonly _metadata: Metadata | undefined;
  // @ts-ignore : 'Model' found in JSON Spec
  private readonly _models: Model[] | undefined;

  constructor(opts: GroundOptions) {
    this.name = opts.name;

    this._args = opts.args ?? undefined;
    this._description = opts.description ?? undefined;
    this._metadata = opts.metadata ?? undefined;
    this._models = opts.models ?? undefined;

    if ('absoluteTime' in opts) {
      this._absoluteTime = opts.absoluteTime;
    } else if ('epochTime' in opts) {
      this._epochTime = opts.epochTime;
    } else if ('relativeTime' in opts) {
      this._relativeTime = opts.relativeTime;
    }
  }

  public static new(opts: GroundOptions): Ground_Event {
    return new Ground_Event(opts);
  }

  public absoluteTiming(absoluteTime: Temporal.Instant): Ground_Event {
    return new Ground_Event({
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { model: this._models } : {}),
      name: this.name,
      absoluteTime: absoluteTime,
    });
  }

  public epochTiming(epochTime: Temporal.Duration): Ground_Event {
    return new Ground_Event({
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { model: this._models } : {}),
      name: this.name,
      epochTime: epochTime,
    });
  }

  public relativeTiming(relativeTime: Temporal.Duration): Ground_Event {
    return new Ground_Event({
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { model: this._models } : {}),
      name: this.name,
      relativeTime: relativeTime,
    });
  }

  // @ts-ignore : 'Model' found in JSON Spec
  public MODELS(models: Model[]): Ground_Event {
    return Ground_Event.new({
      name: this.name,
      models: models,
      ...(this._args && { args: this._args }),
      ...(this._description && { description: this._description }),
      ...(this._metadata && { metadata: this._metadata }),
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }

  // @ts-ignore : 'Model' found in JSON Spec
  public GET_MODELS(): Model[] | undefined {
    return this._models;
  }

  // @ts-ignore : 'Metadata' found in JSON Spec
  public METADATA(metadata: Metadata): Ground_Event {
    return Ground_Event.new({
      name: this.name,
      ...(this._models && { models: this._models }),
      ...(this._args && { args: this._args }),
      ...(this._description && { description: this._description }),
      metadata: metadata,
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }

  // @ts-ignore : 'Metadata' found in JSON Spec
  public GET_METADATA(): Metadata | undefined {
    return this._metadata;
  }

  // @ts-ignore : 'Description' found in JSON Spec
  public DESCRIPTION(description: Description): Ground_Event {
    return Ground_Event.new({
      name: this.name,
      ...(this._models && { models: this._models }),
      ...(this._args && { args: this._args }),
      description: description,
      ...(this._metadata && { metadata: this._metadata }),
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }
  // @ts-ignore : 'Description' found in JSON Spec
  public GET_DESCRIPTION(): Description | undefined {
    return this._description;
  }

  // @ts-ignore : 'Description' found in JSON Spec
  public ARGUMENTS(args: Args): Ground_Event {
    return Ground_Event.new({
      name: this.name,
      ...(this._models && { models: this._models }),
      args: args,
      ...(this._description && { description: this._description }),
      ...(this._metadata && { metadata: this._metadata }),
      ...(this._absoluteTime && { absoluteTime: this._absoluteTime }),
      ...(this._epochTime && { epochTime: this._epochTime }),
      ...(this._relativeTime && { relativeTime: this._relativeTime }),
    });
  }

  // @ts-ignore : 'Description' found in JSON Spec
  public GET_ARGUMENTS(): Args | undefined {
    return this._args;
  }

  // @ts-ignore : 'Ground_Event' found in JSON Spec
  public toSeqJson(): GroundEvent {
    return {
      name: this.name,
      time:
        this._absoluteTime !== null
          ? { type: TimingTypes.ABSOLUTE, tag: instantToDoy(this._absoluteTime) }
          : this._epochTime !== null
          ? { type: TimingTypes.EPOCH_RELATIVE, tag: durationToHms(this._epochTime) }
          : this._relativeTime !== null
          ? { type: TimingTypes.COMMAND_RELATIVE, tag: durationToHms(this._relativeTime) }
          : { type: TimingTypes.COMMAND_COMPLETE },
      ...(this._args ? { args: this._args } : {}),
      ...(this._description ? { description: this._description } : {}),
      ...(this._metadata ? { metadata: this._metadata } : {}),
      ...(this._models ? { models: this._models } : {}),
      type: this.type,
    };
  }

  // @ts-ignore : 'GroundEvent' found in JSON Spec
  public static fromSeqJson(json: GroundEvent): Ground_Event {
    const timeValue =
      json.time.type === TimingTypes.ABSOLUTE
        ? { absoluteTime: doyToInstant(json.time.tag as DOY_STRING) }
        : json.time.type === TimingTypes.COMMAND_RELATIVE
        ? { relativeTime: hmsToDuration(json.time.tag as HMS_STRING) }
        : json.time.type === TimingTypes.EPOCH_RELATIVE
        ? { epochTime: hmsToDuration(json.time.tag as HMS_STRING) }
        : {};

    return Ground_Event.new({
      name: json.name,
      ...(json.args ? { args: json.args } : {}),
      ...(json.description ? { description: json.description } : {}),
      ...(json.metadata ? { metadata: json.metadata } : {}),
      ...(json.models ? { models: json.models } : {}),
      ...timeValue,
    });
  }

  public toEDSLString(): string {
    const timeString = this._absoluteTime
      ? \`A\\\`\${instantToDoy(this._absoluteTime)}\\\`\`
      : this._epochTime
      ? \`E\\\`\${durationToHms(this._epochTime)}\\\`\`
      : this._relativeTime
      ? \`R\\\`\${durationToHms(this._relativeTime)}\\\`\`
      : 'C';

    const args =
      this._args && Object.keys(this._args).length !== 0
        ? // @ts-ignore : 'A : Args' found in JSON Spec
          \`\\n.ARGUMENTS([\\n\${this._args.map(a => indent(objectToString(a))).join(',\\n')}\\n])\`
        : '';

    const metadata =
      this._metadata && Object.keys(this._metadata).length !== 0
        ? \`\\n.METADATA(\${objectToString(this._metadata)})\`
        : '';

    const description =
      this._description && this._description.length !== 0 ? \`\\n.DESCRIPTION('\${this._description}')\` : '';

    const models =
      this._models && Object.keys(this._models).length !== 0
        ? \`\\n.MODELS([\\n\${this._models.map(m => indent(objectToString(m))).join(',\\n')}\\n])\`
        : '';

    return \`\${timeString}.GROUND_EVENT('\${this.name}')\${args}\${description}\${metadata}\${models}\`;
  }
}

/**
 * This is a Ground Event step
 *
 */
function GROUND_EVENT(name: string) {
  return new Ground_Event({ name: name });
}

export const STEPS = {
  GROUND_BLOCK: GROUND_BLOCK,
  GROUND_EVENT: GROUND_EVENT,
};

/*
	---------------------------------
			Time Utilities
	---------------------------------
	*/

export type DOY_STRING = string & { __brand: 'DOY_STRING' };
export type HMS_STRING = string & { __brand: 'HMS_STRING' };

const DOY_REGEX = /(\\d{4})-(\\d{3})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{3}))?/;
const HMS_REGEX = /(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{3}))?/;

/** YYYY-DOYTHH:MM:SS.sss */
export function instantToDoy(time: Temporal.Instant): DOY_STRING {
  const utcZonedDate = time.toZonedDateTimeISO('UTC');
  const YYYY = formatNumber(utcZonedDate.year, 4);
  const DOY = formatNumber(utcZonedDate.dayOfYear, 3);
  const HH = formatNumber(utcZonedDate.hour, 2);
  const MM = formatNumber(utcZonedDate.minute, 2);
  const SS = formatNumber(utcZonedDate.second, 2);
  const sss = formatNumber(utcZonedDate.millisecond, 3);
  return \`\${YYYY}-\${DOY}T\${HH}:\${MM}:\${SS}.\${sss}\` as DOY_STRING;
}

export function doyToInstant(doy: DOY_STRING): Temporal.Instant {
  const match = doy.match(DOY_REGEX);
  if (match === null) {
    throw new Error(\`Invalid DOY string: \${doy}\`);
  }
  const [, year, doyStr, hour, minute, second, millisecond] = match as [
    unknown,
    string,
    string,
    string,
    string,
    string,
    string | undefined,
  ];

  //use to convert doy to month and day
  const doyDate = new Date(parseInt(year, 10), 0, parseInt(doyStr, 10));
  // convert to UTC Date
  const utcDoyDate = new Date(
    Date.UTC(
      doyDate.getUTCFullYear(),
      doyDate.getUTCMonth(),
      doyDate.getUTCDate(),
      doyDate.getUTCHours(),
      doyDate.getUTCMinutes(),
      doyDate.getUTCSeconds(),
      doyDate.getUTCMilliseconds(),
    ),
  );

  return Temporal.ZonedDateTime.from({
    year: parseInt(year, 10),
    month: utcDoyDate.getUTCMonth() + 1,
    day: utcDoyDate.getUTCDate(),
    hour: parseInt(hour, 10),
    minute: parseInt(minute, 10),
    second: parseInt(second, 10),
    millisecond: parseInt(millisecond ?? '0', 10),
    timeZone: 'UTC',
  }).toInstant();
}

/** HH:MM:SS.sss */
export function durationToHms(time: Temporal.Duration): HMS_STRING {
  const HH = formatNumber(time.hours, 2);
  const MM = formatNumber(time.minutes, 2);
  const SS = formatNumber(time.seconds, 2);
  const sss = formatNumber(time.milliseconds, 3);

  return \`\${HH}:\${MM}:\${SS}.\${sss}\` as HMS_STRING;
}

export function hmsToDuration(hms: HMS_STRING): Temporal.Duration {
  const match = hms.match(HMS_REGEX);
  if (match === null) {
    throw new Error(\`Invalid HMS string: \${hms}\`);
  }
  const [, hours, minutes, seconds, milliseconds] = match as [unknown, string, string, string, string | undefined];
  return Temporal.Duration.from({
    hours: parseInt(hours, 10),
    minutes: parseInt(minutes, 10),
    seconds: parseInt(seconds, 10),
    milliseconds: parseInt(milliseconds ?? '0', 10),
  });
}

function formatNumber(number: number, size: number): string {
  return number.toString().padStart(size, '0');
}

// @ts-ignore : Used in generated code
function A(
  ...args: [TemplateStringsArray, ...string[]] | [Temporal.Instant] | [string]
): // @ts-ignore : Commands Used in generated code
typeof Commands & typeof STEPS {
  let time: Temporal.Instant;
  if (Array.isArray(args[0])) {
    time = doyToInstant(String.raw(...(args as [TemplateStringsArray, ...string[]])) as DOY_STRING);
  } else if (typeof args[0] === 'string') {
    time = doyToInstant(args[0] as DOY_STRING);
  } else {
    time = args[0] as Temporal.Instant;
  }

  return commandsWithTimeValue(time, TimingTypes.ABSOLUTE);
}

// @ts-ignore : Used in generated code
function R(
  ...args: [TemplateStringsArray, ...string[]] | [Temporal.Duration] | [string]
): // @ts-ignore : Commands Used in generated code
typeof Commands & typeof STEPS {
  let duration: Temporal.Duration;
  if (Array.isArray(args[0])) {
    duration = hmsToDuration(String.raw(...(args as [TemplateStringsArray, ...string[]])) as HMS_STRING);
  } else if (typeof args[0] === 'string') {
    duration = hmsToDuration(args[0] as HMS_STRING);
  } else {
    duration = args[0] as Temporal.Duration;
  }

  return commandsWithTimeValue(duration, TimingTypes.COMMAND_RELATIVE);
}

// @ts-ignore : Used in generated code
function E(
  ...args: [TemplateStringsArray, ...string[]] | [Temporal.Duration] | [string]
): // @ts-ignore : Commands Used in generated code
typeof Commands & typeof STEPS {
  let duration: Temporal.Duration;
  if (Array.isArray(args[0])) {
    duration = hmsToDuration(String.raw(...(args as [TemplateStringsArray, ...string[]])) as HMS_STRING);
  } else if (typeof args[0] === 'string') {
    duration = hmsToDuration(args[0] as HMS_STRING);
  } else {
    duration = args[0] as Temporal.Duration;
  }
  return commandsWithTimeValue(duration, TimingTypes.EPOCH_RELATIVE);
}

function commandsWithTimeValue<T extends TimingTypes>(
  timeValue: Temporal.Instant | Temporal.Duration,
  timeType: T,
  // @ts-ignore : Commands Used in generated code
): typeof Commands & typeof STEPS {
  return {
    // @ts-ignore : Commands Used in generated code
    ...Object.keys(Commands).reduce((accum, key) => {
      // @ts-ignore : Used in generated code
      const command = Commands[key as keyof Commands];

      if (typeof command === 'function') {
        //if (timeType === TimingTypes.ABSOLUTE) {
        accum[key] = (...args: Parameters<typeof command>): typeof command => {
          switch (timeType) {
            case TimingTypes.ABSOLUTE:
              return command(...args).absoluteTiming(timeValue);
            case TimingTypes.COMMAND_RELATIVE:
              return command(...args).relativeTiming(timeValue);
            case TimingTypes.EPOCH_RELATIVE:
              return command(...args).epochTiming(timeValue);
          }
        };
      } else {
        switch (timeType) {
          case TimingTypes.ABSOLUTE:
            accum[key] = command.absoluteTiming(timeValue);
            break;
          case TimingTypes.COMMAND_RELATIVE:
            accum[key] = command.relativeTiming(timeValue);
            break;
          case TimingTypes.EPOCH_RELATIVE:
            accum[key] = command.epochTiming(timeValue);
            break;
        }
      }

      return accum;
      // @ts-ignore : Used in generated code
    }, {} as typeof Commands),
    ...Object.keys(STEPS).reduce((accum, key) => {
      // @ts-ignore : Used in generated code
      const step = STEPS[key as keyof STEPS];
      // @ts-ignore : Used in generated code
      accum[key] = (...args: Parameters<typeof step>): typeof step => {
        switch (timeType) {
          case TimingTypes.ABSOLUTE:
            return step(...args).absoluteTiming(timeValue);
          case TimingTypes.COMMAND_RELATIVE:
            return step(...args).relativeTiming(timeValue);
          case TimingTypes.EPOCH_RELATIVE:
            return step(...args).epochTiming(timeValue);
        }
      };

      return accum;
    }, {} as typeof STEPS),
  };
}

/*
	---------------------------------
			Utility Functions
	---------------------------------
	*/

function indent(text: string, numTimes: number = 1, char: string = '  '): string {
  return text
    .split('\\n')
    .map(line => char.repeat(numTimes) + line)
    .join('\\n');
}

// This method takes an object and converts it to a string representation, with each key-value pair on a new line
// and nested objects/arrays indented. The indentLevel parameter specifies the initial indentation level,
// used to prettify the generated eDSL from SeqJSON
function objectToString(obj: any, indentLevel: number = 1): string {
  let output = '';

  const print = (obj: any) => {
    Object.keys(obj).forEach(key => {
      const value = obj[key];

      if (Array.isArray(value)) {
        output += indent(\`\${key}: [\`, indentLevel) + '\\n';
        indentLevel++;
        value.forEach((item: any) => {
          output += indent(\`{\`, indentLevel) + '\\n';
          indentLevel++;
          print(item);
          indentLevel--;
          output += indent(\`},\`, indentLevel) + '\\n';
        });
        indentLevel--;
        output += indent(\`],\`, indentLevel) + '\\n';
      } else if (typeof value === 'object') {
        output += indent(\`\${key}:{\`, indentLevel) + '\\n';
        indentLevel++;
        print(value);
        indentLevel--;
        output += indent(\`},\`, indentLevel) + '\\n';
      } else {
        output += indent(\`\${key}: \${typeof value === 'string' ? \`'\${value}'\` : value},\`, indentLevel) + '\\n';
      }
    });
  };

  output += '{\\n';
  print(obj);
  output += \`}\`;

  return output;
}

/** END Preface */
/** START Sequence JSON Spec */
  //https://github.com/NASA-AMMOS/seq-json-schema/blob/develop/types.ts

  /* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type VariableDeclaration = {
  /**
   * Variable type. Allowed types: FLOAT, INT, STRING, UINT, ENUM.
   */
  type: 'FLOAT' | 'INT' | 'STRING' | 'UINT' | 'ENUM';
  /**
   * User-friendly variable names that will be mapped to FSW variable names. Must begin with a letter and contain only letters, numbers, and underscores.
   */
  name: string;
  /**
   * For enumerated type variables, the name of the corresponding FSW-defined ENUM.
   */
  enum_name?: string;
  /**
   * A list of allowable values for this variable.
   */
  allowable_values?: unknown[];
  /**
   * One or more allowable ranges of values, for FLOAT, INT, or UINT variable types.
   */
  allowable_ranges?: VariableRange[];
  /**
   * The FSW-specified name for this variable that should be used in the translated sequence, in case this must be specified. Used for variables which are specially-handled onboard such as LCS (Last Command Status)
   */
  sc_name?: string;
} & {
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
/**
 * Sequence steps can be grouped into a request, which can then be shifted or adjusted altogether as part of the request.
 */
export type Request = {
  description?: Description;
  ground_epoch?: GroundEpoch;
  metadata?: Metadata;
  /**
   * Request Name, used for tracking commands back to the original request after ground expansion. Must be unique.
   */
  name: string;
  /**
   * Sequence steps that are part of this request.
   *
   * @minItems 1
   */
  steps: [Step, ...Step[]];
  time?: Time;
  type: 'request';
} & Request1;
/**
 * Description. Can be attached to any sequence step.
 */
export type Description = string;
export type Step = Activate | Command | GroundBlock | GroundEvent | Load;
/**
 * Array of command arguments
 */
export type Args = (
  | StringArgument
  | NumberArgument
  | BooleanArgument
  | SymbolArgument
  | HexArgument
  | RepeatArgument
)[];
export type Request1 =
  | {
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    };

export interface SeqJson {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Local variable declarations.
   *
   * @minItems 1
   */
  locals?: [VariableDeclaration, ...VariableDeclaration[]];
  metadata: Metadata;
  /**
   * Parameter variable declarations.
   *
   * @minItems 1
   */
  parameters?: [VariableDeclaration, ...VariableDeclaration[]];
  /**
   * Commands groups into requests
   */
  requests?: Request[];
  /**
   * Sequence steps
   */
  steps?: Step[];
  /**
   * Immediate commands which are interpreted by FSW and not part of any sequence.
   */
  immediate_commands?: ImmediateCommand[];
  /**
   * Hardware commands which are not interpreted by FSW and not part of any sequence.
   */
  hardware_commands?: HardwareCommand[];
  [k: string]: unknown;
}
/**
 * A range of allowable variable values between a defined min and max, inclusive. min and max must be numbers
 */
export interface VariableRange {
  /**
   * Minimum value of the variable, inclusive
   */
  min: number;
  /**
   * Maximum value of the variable, inclusive
   */
  max: number;
}
/**
 * Flexible sequence metadata for any key-value pairs.
 */
export interface Metadata {
  [k: string]: unknown;
}
/**
 * Ground epoch object
 */
export interface GroundEpoch {
  /**
   * Epoch delta given as a duration, start time will be epoch+delta.
   */
  delta?: string;
  /**
   * Name of ground-defined epoch.
   */
  name?: string;
  [k: string]: unknown;
}
/**
 * Activate object
 */
export interface Activate {
  args?: Args;
  description?: Description;
  /**
   * Sequence target engine.
   */
  engine?: number;
  /**
   * Onboard epoch to pass to the sequence for derivation of epoch-relative timetags
   */
  epoch?: string;
  metadata?: Metadata;
  models?: Model[];
  /**
   * Onboard path and filename of sequence to be loaded.
   */
  sequence: string;
  time: Time;
  type: 'activate';
}
/**
 * A step argument containing a string.
 */
export interface StringArgument {
  /**
   * An optional string argument name.
   */
  name?: string;
  /**
   * The string type.
   */
  type: 'string';
  /**
   * A valid string value.
   */
  value: string;
}
/**
 * A step argument containing a number.
 */
export interface NumberArgument {
  /**
   * An optional number argument name.
   */
  name?: string;
  /**
   * The number type.
   */
  type: 'number';
  /**
   * The number value. The number must be valid.
   */
  value: number;
}
/**
 * A step argument containing a boolean.
 */
export interface BooleanArgument {
  /**
   * An optional boolean argument name.
   */
  name?: string;
  /**
   * The boolean type.
   */
  type: 'boolean';
  /**
   * The boolean value. The value must be all lowercase.
   */
  value: boolean;
}
/**
 * A step argument referencing a local or global variable, or some other symbolic name known to downstream modeling software (such as CONDITION in SEQGEN)
 */
export interface SymbolArgument {
  /**
   * An optional symbol argument name.
   */
  name?: string;
  /**
   * The symbol argument type.
   */
  type: 'symbol';
  /**
   * The symbolic name being referenced.
   */
  value: string;
}
/**
 * A step argument containing an unsigned integer in hexadecimal format.
 */
export interface HexArgument {
  /**
   * An optional hex argument name.
   */
  name?: string;
  /**
   * The hex type.
   */
  type: 'hex';
  /**
   * The hexadecimal integer value, as a string prefixed with 0x. Digits A-F must be uppercase.
   */
  value: string;
}
/**
 * An argument that can be repeated.
 */
export interface RepeatArgument {
  /**
   * An optional repeat argument name.
   */
  name?: string;
  /**
   * The repeat argument type.
   */
  type: 'repeat';
  /**
   * A repeat argument value.
   */
  value: (StringArgument | NumberArgument | BooleanArgument | SymbolArgument | HexArgument)[][];
}
/**
 * Model object that be included with commands to set variables for modeling purposes only, usually to direct sequence execution down a particular branch during modeling.
 */
export interface Model {
  /**
   * Duration to wait after step time to trigger model change
   */
  offset: string;
  /**
   * Value to set in variable.
   */
  value: string | number | boolean;
  /**
   * Variable to be set in the model
   */
  variable: string;
}
/**
 * Time object
 */
export interface Time {
  /**
   * Relative or absolute time. Required for ABSOLUTE, COMMAND_RELATIVE, and EPOCH_RELATIVE time tags but not COMMAND_COMPLETE.
   */
  tag?: string;
  /**
   * Allowed time types: ABSOLUTE, COMMAND_RELATIVE, EPOCH_RELATIVE, or COMMAND_COMPLETE.
   */
  type: 'ABSOLUTE' | 'COMMAND_RELATIVE' | 'EPOCH_RELATIVE' | 'COMMAND_COMPLETE';
}
/**
 * Command object
 */
export interface Command {
  args: Args;
  description?: Description;
  metadata?: Metadata;
  models?: Model[];
  /**
   * Command stem
   */
  stem: string;
  time: Time;
  type: 'command';
  /**
   * Name of a defined local variable to which the exit status of this command should be written to. For this to work, that local variable must have been defined with the 'SC_Name' property set to LCS
   */
  return_assign_to?: string;
}
/**
 * Ground blocks
 */
export interface GroundBlock {
  args?: Args;
  description?: Description;
  metadata?: Metadata;
  models?: Model[];
  /**
   * Ground block name
   */
  name: string;
  time: Time;
  type: 'ground_block';
}
/**
 * Ground events
 */
export interface GroundEvent {
  args?: Args;
  description?: Description;
  metadata?: Metadata;
  models?: Model[];
  /**
   * Ground event name
   */
  name: string;
  time: Time;
  type: 'ground_event';
}
/**
 * Load object
 */
export interface Load {
  args?: Args;
  description?: Description;
  /**
   * Sequence target engine.
   */
  engine?: number;
  /**
   * Onboard epoch to pass to the sequence for derivation of epoch-relative timetags
   */
  epoch?: string;
  metadata?: Metadata;
  models?: Model[];
  /**
   * Onboard path and filename of sequence to be loaded.
   */
  sequence: string;
  time: Time;
  type: 'load';
}
/**
 * Object representing a single Immediate Command
 */
export interface ImmediateCommand {
  args: Args;
  description?: Description;
  metadata?: Metadata;
  /**
   * Command stem
   */
  stem: string;
}
/**
 * Object representing a single Hardware Command
 */
export interface HardwareCommand {
  description?: Description;
  metadata?: Metadata;
  /**
   * Command stem
   */
  stem: string;
}

  
/** END Sequence JSON Spec */
declare global {

	interface ECHO extends CommandStem<[ [{ 'echo_string': VarString<8, 1024> }] ]> {}

	interface PREHEAT_OVEN extends CommandStem<[ [{ 'temperature': U8 }] ]> {}

	interface THROW_BANANA extends CommandStem<[ [{ 'distance': U8 }] ]> {}

	interface GROW_BANANA extends CommandStem<[ [{ 'quantity': U8,'durationSecs': U8 }] ]> {}

	interface GrowBanana extends CommandStem<[ [{ 'quantity': U8,'durationSecs': U8 }] ]> {}

	interface PREPARE_LOAF extends CommandStem<[ [{ 'tb_sugar': U8,'gluten_free': ('FALSE' | 'TRUE') }] ]> {}

	interface PEEL_BANANA extends CommandStem<[ [{ 'peelDirection': ('fromStem' | 'fromTip') }] ]> {}


/**
* This command bakes a banana bread
*
*/
	interface BAKE_BREAD extends CommandStem<[]> {}



/**
* This command waters the banana tree
*
*/
	interface ADD_WATER extends CommandStem<[]> {}


	interface PACKAGE_BANANA extends CommandStem<[ [{ 'lot_number': U16,'bundle': Array<{ 'bundle_name': VarString<8, 1024>, 'number_of_bananas': U8 }> }] ]> {}


/**
* Pick a banana
*
*/
	interface PICK_BANANA extends CommandStem<[]> {}



/**
* Eat a banana
*
*/
	interface EAT_BANANA extends CommandStem<[]> {}

	const Commands: {
		ECHO: typeof ECHO,
		PREHEAT_OVEN: typeof PREHEAT_OVEN,
		THROW_BANANA: typeof THROW_BANANA,
		GROW_BANANA: typeof GROW_BANANA,
		GrowBanana: typeof GrowBanana,
		PREPARE_LOAF: typeof PREPARE_LOAF,
		PEEL_BANANA: typeof PEEL_BANANA,
		BAKE_BREAD: typeof BAKE_BREAD,
		ADD_WATER: typeof ADD_WATER,
		PACKAGE_BANANA: typeof PACKAGE_BANANA,
		PICK_BANANA: typeof PICK_BANANA,
		EAT_BANANA: typeof EAT_BANANA,
	};
}


/**
* This command will echo back a string
* @param echo_string String to echo back
*/
function ECHO(...args: [{ 'echo_string': VarString<8, 1024> }]) {
  return CommandStem.new({
    stem: 'ECHO',
    arguments: args
  }) as ECHO;
}


/**
* This command will turn on the oven
* @param temperature Set the oven temperature
*/
function PREHEAT_OVEN(...args: [{ 'temperature': U8 }]) {
  return CommandStem.new({
    stem: 'PREHEAT_OVEN',
    arguments: args
  }) as PREHEAT_OVEN;
}


/**
* This command will throw a banana
* @param distance The distance you throw the bananan
*/
function THROW_BANANA(...args: [{ 'distance': U8 }]) {
  return CommandStem.new({
    stem: 'THROW_BANANA',
    arguments: args
  }) as THROW_BANANA;
}


/**
* This command will grow bananas
* @param quantity Number of bananas to grow
* @param durationSecs How many seconds will it take to grow
*/
function GROW_BANANA(...args: [{ 'quantity': U8,'durationSecs': U8 }]) {
  return CommandStem.new({
    stem: 'GROW_BANANA',
    arguments: args
  }) as GROW_BANANA;
}


/**
* This command will grow bananas, it's a duplicate to clash with an activity type of the same name
* @param quantity Number of bananas to grow
* @param durationSecs How many seconds will it take to grow
*/
function GrowBanana(...args: [{ 'quantity': U8,'durationSecs': U8 }]) {
  return CommandStem.new({
    stem: 'GrowBanana',
    arguments: args
  }) as GrowBanana;
}


/**
* This command make the banana bread dough
* @param tb_sugar How much sugar is needed
* @param gluten_free Do you hate flavor
*/
function PREPARE_LOAF(...args: [{ 'tb_sugar': U8,'gluten_free': ('FALSE' | 'TRUE') }]) {
  return CommandStem.new({
    stem: 'PREPARE_LOAF',
    arguments: args
  }) as PREPARE_LOAF;
}


/**
* This command peels a single banana
* @param peelDirection Which way do you peel the banana
*/
function PEEL_BANANA(...args: [{ 'peelDirection': ('fromStem' | 'fromTip') }]) {
  return CommandStem.new({
    stem: 'PEEL_BANANA',
    arguments: args
  }) as PEEL_BANANA;
}


/**
* This command bakes a banana bread
*
*/
const BAKE_BREAD: BAKE_BREAD = CommandStem.new({
	stem: 'BAKE_BREAD',
	arguments: [],
})


/**
* This command waters the banana tree
*
*/
const ADD_WATER: ADD_WATER = CommandStem.new({
	stem: 'ADD_WATER',
	arguments: [],
})


/**
* Dynamically bundle bananas into lots
* @param lot_number Identification number assigned to a particular quantity
* @param bundle A repeated set of strings and integer containing the arguments to the lot
*/
function PACKAGE_BANANA(...args: [{ 'lot_number': U16,'bundle': Array<{ 'bundle_name': VarString<8, 1024>, 'number_of_bananas': U8 }> }]) {
  return CommandStem.new({
    stem: 'PACKAGE_BANANA',
    arguments: args
  }) as PACKAGE_BANANA;
}


/**
* Pick a banana
*
*/
const PICK_BANANA: PICK_BANANA = CommandStem.new({
	stem: 'PICK_BANANA',
	arguments: [],
})


/**
* Eat a banana
*
*/
const EAT_BANANA: EAT_BANANA = CommandStem.new({
	stem: 'EAT_BANANA',
	arguments: [],
})
export const Commands = {		ECHO: ECHO,
		PREHEAT_OVEN: PREHEAT_OVEN,
		THROW_BANANA: THROW_BANANA,
		GROW_BANANA: GROW_BANANA,
		GrowBanana: GrowBanana,
		PREPARE_LOAF: PREPARE_LOAF,
		PEEL_BANANA: PEEL_BANANA,
		BAKE_BREAD: BAKE_BREAD,
		ADD_WATER: ADD_WATER,
		PACKAGE_BANANA: PACKAGE_BANANA,
		PICK_BANANA: PICK_BANANA,
		EAT_BANANA: EAT_BANANA,
};

Object.assign(globalThis, { A:A, R:R, E:E, C:Object.assign(Commands, STEPS), Sequence});
"
`;
