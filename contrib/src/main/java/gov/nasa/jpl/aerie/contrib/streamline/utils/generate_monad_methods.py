import datetime
import os
import string
from collections import namedtuple
from functools import partial

GENERATED_SECTION_START_COMMENT = '// GENERATED CODE START'
GENERATED_SECTION_END_COMMENT = '// GENERATED CODE END'


# Target file names are relative to this file's directory
Target = namedtuple('Target', ['monad_pattern', 'file_name', 'included_methods'])
applicative = partial(Target, included_methods={'apply', 'map'})
monad = partial(Target, included_methods={'apply', 'map', 'bind'})
TARGETS = [
    monad('Resource<{}>', '../core/monads/ResourceMonad.java'),
    monad('ErrorCatching<Expiring<{}>>', '../core/monads/DynamicsMonad.java'),
    monad('Expiring<{}>', '../core/monads/ExpiringMonad.java'),
    monad('ErrorCatching<{}>', '../core/monads/ErrorCatchingMonad.java'),
    monad('ThinResource<{}>', '../core/monads/ThinResourceMonad.java'),
    monad('Discrete<{}>', '../modeling/discrete/monads/DiscreteMonad.java'),
    monad('Resource<Discrete<{}>>', '../modeling/discrete/monads/DiscreteResourceMonad.java'),
    monad('ErrorCatching<Expiring<Discrete<{}>>>', '../modeling/discrete/monads/DiscreteDynamicsMonad.java'),
    monad('Unstructured<{}>', '../modeling/black_box/monads/UnstructuredMonad.java'),
    applicative('Resource<Unstructured<{}>>', '../modeling/black_box/monads/UnstructuredResourceApplicative.java'),
    applicative('ErrorCatching<Expiring<Unstructured<{}>>>', '../modeling/black_box/monads/UnstructuredDynamicsApplicative.java'),
]


def main(n):
    for target in TARGETS:
        target_file = os.path.join(os.path.dirname(__file__), target.file_name)
        print(f'Adding supplemental monad methods to {target_file}...')
        supplemental_methods_content = generate_supplemental_methods(target, n)
        insert_into_target_file(target_file, supplemental_methods_content)
    print('All supplemental monad methods added.')


def insert_into_target_file(target_file, content):
    with open(target_file) as f:
        original_lines = list(f)

    modified_lines = list(original_lines)
    stripped_lines = [l.strip() for l in original_lines]
    try:
        generated_section_start = stripped_lines.index(GENERATED_SECTION_START_COMMENT)
        generated_section_end = stripped_lines.index(GENERATED_SECTION_END_COMMENT) + 1
        # Detect indentation that was used before:
        indentation = len(original_lines[generated_section_start]) - len(
            original_lines[generated_section_start].lstrip())
    except ValueError:
        stripped_lines.reverse()
        final_brace_line = len(stripped_lines) - stripped_lines.index('}') - 1
        stripped_lines.reverse()
        # Detect indentation of the last non-blank line
        i = final_brace_line - 1
        while stripped_lines[i] == '':
            i -= 1
        indentation = len(original_lines[i]) - len(original_lines[i].lstrip())
        # Insert a blank line before the generated section, if none exists:
        if i == final_brace_line - 1:
            modified_lines.insert(final_brace_line, '\n')
            final_brace_line += 1
        # Set the generated section to be inserted just before the final closing brace
        generated_section_start = final_brace_line
        generated_section_end = generated_section_start

    # generated_section_start and generated_section_end now indicate where in modified_lines to edit
    modified_content = [' ' * indentation + l + '\n' for l in content.split('\n')]
    modified_content.insert(0, ' ' * indentation + GENERATED_SECTION_START_COMMENT + '\n')
    modified_content.append(' ' * indentation + GENERATED_SECTION_END_COMMENT + '\n')
    modified_lines[generated_section_start:generated_section_end] = modified_content

    with open(target_file, 'w') as f:
        f.writelines(modified_lines)


def generate_supplemental_methods(target, n):
    result = f'// Supplemental methods generated by {os.path.basename(__file__)} on {datetime.date.today().isoformat()}.'
    if 'apply' in target.included_methods:
        result += '\n' + generate_functional_apply(target.monad_pattern)
    if 'map' in target.included_methods:
        result += '\n' + generate_1_arg_map(target.monad_pattern)
        result += '\n' + generate_1_arg_functional_map(target.monad_pattern)
    if 'bind' in target.included_methods:
        result += '\n' + generate_1_arg_bind(target.monad_pattern)
        result += '\n' + generate_1_arg_functional_bind(target.monad_pattern)
    for i in range(2, n + 1):
        if 'map' in target.included_methods:
            result += '\n' + generate_n_arg_map(i, target.monad_pattern)
            result += '\n' + generate_n_arg_curried_map(i, target.monad_pattern)
            result += '\n' + generate_n_arg_functional_map(i, target.monad_pattern)
        if 'bind' in target.included_methods:
            result += '\n' + generate_n_arg_bind(i, target.monad_pattern)
            result += '\n' + generate_n_arg_curried_bind(i, target.monad_pattern)
            result += '\n' + generate_n_arg_functional_bind(i, target.monad_pattern)
    return result


def generate_functional_apply(monad_pattern):
    MA = monad_pattern.format('A')
    MB = monad_pattern.format('B')
    M_AB = monad_pattern.format('Function<A, B>')
    return f'''
public static <A, B> Function<{MA}, {MB}> apply({M_AB} f) {{
  return a -> apply(a, f);
}}'''


def generate_1_arg_functional_map(monad_pattern):
    MA = monad_pattern.format('A')
    MB = monad_pattern.format('B')
    return f'''
public static <A, B> Function<{MA}, {MB}> map(Function<A, B> f) {{
  return apply(pure(f));
}}'''


def generate_1_arg_functional_bind(monad_pattern):
    MA = monad_pattern.format('A')
    MB = monad_pattern.format('B')
    return f'''
public static <A, B> Function<{MA}, {MB}> bind(Function<A, {MB}> f) {{
  return a -> bind(a, f);
}}'''


def generate_1_arg_map(monad_pattern):
    MA = monad_pattern.format('A')
    MB = monad_pattern.format('B')
    return f'''
public static <A, B> {MB} map({MA} a, Function<A, B> f) {{
  return apply(a, pure(f));
}}'''


def generate_1_arg_bind(monad_pattern):
    MA = monad_pattern.format('A')
    MB = monad_pattern.format('B')
    return f'''
public static <A, B> {MB} bind({MA} a, Function<A, {MB}> f) {{
  return join(map(a, f));
}}'''


def generate_n_arg_map(n, monad_pattern):
    arg_signature = ', '.join(
        f'{monad_pattern.format(c)} {c.lower()}'
        for c in string.ascii_uppercase[:n])
    fn_name = (
        'BiFunction' if n == 2 else
        'TriFunction' if n == 3 else
        f'Function{n}')
    type_args = f'<{", ".join(string.ascii_uppercase[:n])}, Result>'
    fn_type = fn_name + type_args
    args = ', '.join(string.ascii_lowercase[:n])
    return f'''
public static {type_args} {monad_pattern.format('Result')} map({arg_signature}, {fn_type} function) {{
  return map({args}, curry(function));
}}'''


def generate_n_arg_functional_map(n, monad_pattern):
    fn_name = (
        'BiFunction' if n == 2 else
        'TriFunction' if n == 3 else
        f'Function{n}')
    type_args = f'<{", ".join(string.ascii_uppercase[:n])}, Result>'
    fn_type = fn_name + type_args
    result_fn_type = f'{fn_name}<{", ".join(monad_pattern.format(c) for c in string.ascii_uppercase[:n])}, {monad_pattern.format("Result")}>'
    args = ', '.join(string.ascii_lowercase[:n])
    return f'''
public static {type_args} {result_fn_type} map({fn_type} function) {{
  return ({args}) -> map({args}, function);
}}'''


def generate_n_arg_curried_map(n, monad_pattern):
    arg_signature = ', '.join(
        f'{monad_pattern.format(c)} {c.lower()}'
        for c in string.ascii_uppercase[:n])
    type_args = f'<{", ".join(string.ascii_uppercase[:n])}, Result>'
    fn_type = generate_n_arg_curried_function_type(n, 'Result')
    last_arg = string.ascii_lowercase[n - 1]
    non_last_args = ', '.join(string.ascii_lowercase[:n - 1])
    return f'''
public static {type_args} {monad_pattern.format('Result')} map({arg_signature}, {fn_type} function) {{
  return apply({last_arg}, map({non_last_args}, function));
}}'''


def generate_n_arg_bind(n, monad_pattern):
    arg_signature = ', '.join(
        f'{monad_pattern.format(c)} {c.lower()}'
        for c in string.ascii_uppercase[:n])
    fn_name = (
        'BiFunction' if n == 2 else
        'TriFunction' if n == 3 else
        f'Function{n}')
    type_args = f'<{", ".join(string.ascii_uppercase[:n])}, Result>'
    monadic_result = monad_pattern.format('Result')
    fn_type = f'{fn_name}<{", ".join(string.ascii_uppercase[:n])}, {monadic_result}>'
    args = ', '.join(string.ascii_lowercase[:n])
    return f'''
public static {type_args} {monadic_result} bind({arg_signature}, {fn_type} function) {{
  return join(map({args}, function));
}}'''


def generate_n_arg_functional_bind(n, monad_pattern):
    fn_name = (
        'BiFunction' if n == 2 else
        'TriFunction' if n == 3 else
        f'Function{n}')
    type_args = f'<{", ".join(string.ascii_uppercase[:n])}, Result>'
    monadic_result = monad_pattern.format('Result')
    fn_type = f'{fn_name}<{", ".join(string.ascii_uppercase[:n])}, {monadic_result}>'
    result_fn_type = f'{fn_name}<{", ".join(monad_pattern.format(c) for c in string.ascii_uppercase[:n])}, {monadic_result}>'
    args = ', '.join(string.ascii_lowercase[:n])
    return f'''
public static {type_args} {result_fn_type} bind({fn_type} function) {{
  return ({args}) -> bind({args}, function);
}}'''


def generate_n_arg_curried_bind(n, monad_pattern):
    arg_signature = ', '.join(
        f'{monad_pattern.format(c)} {c.lower()}'
        for c in string.ascii_uppercase[:n])
    type_args = f'<{", ".join(string.ascii_uppercase[:n])}, Result>'
    monadic_result = monad_pattern.format('Result')
    fn_type = generate_n_arg_curried_function_type(n, monadic_result)
    args = ', '.join(string.ascii_lowercase[:n])
    return f'''
public static {type_args} {monad_pattern.format('Result')} bind({arg_signature}, {fn_type} function) {{
  return join(map({args}, function));
}}'''


def generate_n_arg_curried_function_type(n, result):
    for c in reversed(string.ascii_uppercase[:n]):
        result = f'Function<{c}, {result}>'
    return result


if __name__ == '__main__':
    import sys

    if '-h' in sys.argv or '--help' in sys.argv:
        targets_str = ''.join('\n      ' + t.file_name for t in TARGETS)
        print(f'''
Usage: {sys.argv[0]} N

Generates supplementary monad methods.

Assuming a monad M has defined the following methods:
      pure :: A -> M A
      apply :: M A, M(A -> B) -> M B
      join :: M (M A) -> M A
This script will generate the following methods:
      apply :: M(A -> B) -> (M A -> M B)
      map :: M A, (A -> B) -> M B
      map :: (A -> B) -> (M A -> M B)
      bind :: M A, (A -> M B) -> M B
      bind :: (A -> M B) -> (M A -> M B)
      k-argument forms of map and bind, for k up to N, taking regular or curried mapping functions

These methods will be added to the following classes:
{targets_str}

Args:
      N    Integer, the maximum arity to generate support for.
''')
        exit(0)
    main(int(sys.argv[1]))
