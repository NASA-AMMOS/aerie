create table activity_directive (
  id integer generated by default as identity,
  plan_id integer not null,

  name text,
  source_scheduling_goal_id integer,
  created_at timestamptz not null default now(),
  created_by text,
  last_modified_at timestamptz not null default now(),
  last_modified_by text,
  start_offset interval not null,
  type text not null,
  arguments merlin_argument_set not null,
  last_modified_arguments_at timestamptz not null default now(),
  metadata merlin_activity_directive_metadata_set default '{}'::jsonb,

  anchor_id integer default null,
  anchored_to_start boolean default true not null,
  constraint activity_directive_natural_key
    primary key (id, plan_id),
  constraint activity_directive_owned_by_plan
    foreign key (plan_id)
    references plan
    on update cascade
    on delete cascade,
  -- An activity cannot anchor to an activity in another plan
  constraint anchor_in_plan
    foreign key (anchor_id, plan_id)
      references activity_directive
      on update cascade
      on delete restrict,
  constraint activity_directive_last_modified_by_exists
    foreign key (last_modified_by)
    references metadata.users
    on update cascade
    on delete set null,
  constraint activity_directive_created_by_exists
    foreign key (created_by)
    references metadata.users
    on update cascade
    on delete set null
);

create index activity_directive_plan_id_index on activity_directive (plan_id);


comment on table activity_directive is e''
  'A single activity_directive within a plan.';

comment on column activity_directive.id is e''
  'The synthetic identifier for this activity_directive.\n'
  'Unique within a given plan.';
comment on column activity_directive.plan_id is e''
  'The plan within which this activity_directive is located.';
comment on column activity_directive.name is e''
  'The name of this activity_directive.';
comment on column activity_directive.source_scheduling_goal_id is e''
  'The scheduling goal that this activity_directive was generated by.';
comment on column activity_directive.created_at is e''
  'The time at which this activity_directive was created.';
comment on column activity_directive.created_by is e''
  'The user who originally created this activity_directive.';
comment on column activity_directive.last_modified_at is e''
  'The time at which this activity_directive was last modified.';
comment on column activity_directive.last_modified_by is e''
  'The user who last modified this activity_directive.';
comment on column activity_directive.last_modified_arguments_at is e''
  'The time at which this activity_directive.arguments was last modified.';
comment on column activity_directive.start_offset is e''
  'The non-negative time offset from the start of the plan at which this activity_directive is scheduled.';
comment on column activity_directive.type is e''
  'The type of the activity_directive, as defined in the mission model associated with the plan.';
comment on column activity_directive.arguments is e''
  'The set of arguments to this activity_directive, corresponding to the parameters of the associated activity type.';
comment on column activity_directive.metadata is e''
  'The metadata associated with this activity_directive.';
comment on column activity_directive.anchor_id is e''
  'The id of the activity_directive this activity_directive is anchored to. '
  'The value null indicates that this activity_directive is anchored to the plan.';
comment on column activity_directive.anchored_to_start is e''
  'If true, this activity_directive is anchored to the start time of its anchor. '
  'If false, this activity_directive is anchored to the end time of its anchor.';

create procedure plan_locked_exception(plan_id integer)
language plpgsql as $$
  begin
    if(select is_locked from plan where plan.id = plan_id limit 1) then
      raise exception 'Plan % is locked.', plan_id;
    end if;
  end
$$;

comment on procedure plan_locked_exception(plan_id integer) is e''
  'Verify that the plan corresponding to the activity being updated is unlocked, throwing an exception if not.';

create function increment_revision_on_insert_activity_directive()
returns trigger
security definer
language plpgsql as $$begin
  update plan
  set revision = revision + 1
  where id = new.plan_id;

  return new;
end$$;

create trigger increment_revision_on_insert_activity_directive_trigger
after insert on activity_directive
for each row
execute function increment_revision_on_insert_activity_directive();

create function increment_revision_on_update_activity_directive()
returns trigger
security definer
language plpgsql as $$begin
  update plan
  set revision = revision + 1
  where id = new.plan_id
    or id = old.plan_id;

  return new;
end$$;

create trigger increment_revision_on_update_activity_directive_trigger
after update on activity_directive
for each row
execute function increment_revision_on_update_activity_directive();

create function increment_revision_on_delete_activity_directive()
returns trigger
security definer
language plpgsql as $$begin
  update plan
  set revision = revision + 1
  where id = old.plan_id;

  return old;
end$$;

create trigger increment_revision_on_delete_activity_directive_trigger
after delete on activity_directive
for each row
execute function increment_revision_on_delete_activity_directive();

create function generate_activity_directive_name()
returns trigger
security definer
language plpgsql as $$begin
  call plan_locked_exception(new.plan_id);
  if new.name is null
  then new.name = new.type || ' ' || new.id;
  end if;
  return new;
end$$;

comment on function generate_activity_directive_name() is e''
  'Generates a name for an activity_directive as the activity type + activity id.';

create trigger generate_name_trigger
before insert on activity_directive
for each row execute function generate_activity_directive_name();

comment on trigger generate_name_trigger on activity_directive is e''
  'Generates a name for an activity_directive as the activity type + activity id.';

create function activity_directive_set_updated_at()
  returns trigger
  security definer
  language plpgsql as $$begin
    call plan_locked_exception(new.plan_id);
    new.last_modified_at = now();
  return new;
end$$;

comment on function activity_directive_set_updated_at() is e''
  'Sets the last_modified_at field of an activity_directive to the current time.';

create trigger set_timestamp
  before update on activity_directive
  for each row
execute function activity_directive_set_updated_at();

comment on trigger set_timestamp on activity_directive is e''
  'Sets the last_modified_at field of an activity_directive to the current time.';

create function activity_directive_set_arguments_updated_at()
  returns trigger
  security definer
  language plpgsql as
$$ begin
  call plan_locked_exception(new.plan_id);
  new.last_modified_arguments_at = now();

  -- request new validation
  update activity_directive_validations
    set last_modified_arguments_at = new.last_modified_arguments_at,
        status = 'pending'
    where (directive_id, plan_id) = (new.id, new.plan_id);

  return new;
end $$;

comment on function activity_directive_set_arguments_updated_at() is e''
  'Sets the last_modified_arguments_at field of an activity_directive to the current time.';

create trigger set_arguments_timestamp
  before update of arguments on activity_directive
  for each row
execute function activity_directive_set_arguments_updated_at();

comment on trigger set_arguments_timestamp on activity_directive is e''
  'Sets the last_modified_arguments_at field of an activity_directive to the current time.';

create function activity_directive_validation_entry()
  returns trigger
  security definer
  language plpgsql as
$$ begin
  insert into activity_directive_validations
    (directive_id, plan_id, last_modified_arguments_at)
    values (new.id, new.plan_id, new.last_modified_arguments_at);
  return new;
end $$;

create trigger validation_entry_on_insert
  after insert on activity_directive
  for each row
execute function activity_directive_validation_entry();

create function check_activity_directive_metadata()
returns trigger
security definer
language plpgsql as $$
  declare
    _key text;
    _value jsonb;
    _schema jsonb;
    _type text;
    _subValue jsonb;
  begin
  call plan_locked_exception(new.plan_id);
  for _key, _value in
    select * from jsonb_each(new.metadata::jsonb)
  loop
    select schema into _schema from activity_directive_metadata_schema where key = _key;
    _type := _schema->>'type';
    if _type = 'string' then
      if jsonb_typeof(_value) != 'string' then
        raise exception 'invalid metadata value for key %. Expected: string, Received: %', _key, _value;
      end if;
    elsif _type = 'long_string' then
      if jsonb_typeof(_value) != 'string' then
        raise exception 'invalid metadata value for key %. Expected: string, Received: %', _key, _value;
      end if;
    elsif _type = 'boolean' then
      if jsonb_typeof(_value) != 'boolean' then
        raise exception 'invalid metadata value for key %. Expected: boolean, Received: %', _key, _value;
      end if;
    elsif _type = 'number' then
      if jsonb_typeof(_value) != 'number' then
        raise exception 'invalid metadata value for key %. Expected: number, Received: %', _key, _value;
      end if;
    elsif _type = 'enum' then
      if (_value not in (select * from jsonb_array_elements(_schema->'enumerates'))) then
        raise exception 'invalid metadata value for key %. Expected: %, Received: %', _key, _schema->>'enumerates', _value;
      end if;
    elsif _type = 'enum_multiselect' then
      if jsonb_typeof(_value) != 'array' then
        raise exception 'invalid metadata value for key %. Expected an array of enumerates: %, Received: %', _key, _schema->>'enumerates', _value;
      end if;
      for _subValue in select * from jsonb_array_elements(_value)
        loop
          if (_subValue not in (select * from jsonb_array_elements(_schema->'enumerates'))) then
            raise exception 'invalid metadata value for key %. Expected one of the valid enumerates: %, Received: %', _key, _schema->>'enumerates', _value;
          end if;
        end loop;
    end if;
  end loop;
  return new;
end$$;

create trigger check_activity_directive_metadata_trigger
before insert or update on activity_directive
for each row
execute function check_activity_directive_metadata();

create function check_locked_on_delete()
  returns trigger
  security definer
  language plpgsql as $$
  begin
    call plan_locked_exception(old.plan_id);
    return old;
  end $$;

create trigger check_locked_on_delete_trigger
before delete on activity_directive
for each row
execute procedure check_locked_on_delete();

create function anchor_direct_descendents_to_plan(_activity_id int, _plan_id int)
  returns setof activity_directive
  language plpgsql as $$
  declare
    _total_offset interval;
  begin
    if _plan_id is null then
      raise exception 'Plan ID cannot be null.';
    end if;
    if _activity_id is null then
      raise exception 'Activity ID cannot be null.';
    end if;
    if not exists(select id from activity_directive where (id, plan_id) = (_activity_id, _plan_id)) then
      raise exception 'Activity Directive % does not exist in Plan %', _activity_id, _plan_id;
    end if;

    with recursive history(activity_id, anchor_id, total_offset) as (
      select ad.id, ad.anchor_id, ad.start_offset
      from activity_directive ad
      where (ad.id, ad.plan_id) = (_activity_id, _plan_id)
      union
      select ad.id, ad.anchor_id, h.total_offset + ad.start_offset
      from activity_directive ad, history h
      where (ad.id, ad.plan_id) = (h.anchor_id, _plan_id)
        and h.anchor_id is not null
    ) select total_offset
    from history
    where history.anchor_id is null
    into _total_offset;

    return query update activity_directive
      set start_offset = start_offset + _total_offset,
          anchor_id = null,
          anchored_to_start = true
      where (anchor_id, plan_id) = (_activity_id, _plan_id)
      returning *;
  end
  $$;
comment on function anchor_direct_descendents_to_plan(_activity_id integer, _plan_id integer) is e''
'Given the primary key of an activity, reanchor all anchor chains attached to the activity to the plan.\n'
'In the event of an end-time anchor, this function assumes all simulated activities have a duration of 0.';

create function anchor_direct_descendents_to_ancestor(_activity_id int, _plan_id int)
  returns setof activity_directive
  language plpgsql as $$
declare
  _current_offset interval;
  _current_anchor_id int;
begin
  if _plan_id is null then
    raise exception 'Plan ID cannot be null.';
  end if;
  if _activity_id is null then
    raise exception 'Activity ID cannot be null.';
  end if;
  if not exists(select id from activity_directive where (id, plan_id) = (_activity_id, _plan_id)) then
    raise exception 'Activity Directive % does not exist in Plan %', _activity_id, _plan_id;
  end if;

  select start_offset, anchor_id
  from activity_directive
  where (id, plan_id) = (_activity_id, _plan_id)
  into _current_offset, _current_anchor_id;

  return query
    update activity_directive
    set start_offset = start_offset + _current_offset,
      anchor_id = _current_anchor_id
    where (anchor_id, plan_id) = (_activity_id, _plan_id)
    returning *;
end
$$;
comment on function anchor_direct_descendents_to_ancestor(_activity_id integer, _plan_id integer) is e''
  'Given the primary key of an activity, reanchor all anchor chains attached to the activity to the anchor of said activity.\n'
  'In the event of an end-time anchor, this function assumes all simulated activities have a duration of 0.';

